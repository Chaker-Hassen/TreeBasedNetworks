# -*- coding: utf-8 -*-
"""Heurostique.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V0XkSIVhzi1lsXjLPlpvOQtsiKpXmFSv
"""

from google.colab import files

"""**Méthode1: Tri des transferts selon le Timestamp**"""

files.upload() # <================= Veuillez importer le fichier 'output_algo2.pkl'

import pickle as pkl

# Ouverture du fichier pickle 'test1_species_tree.pkl' en mode lecture binaire
file1 = open('/content/output_algo2.pkl', 'rb')

# Chargement des données du fichier pickle dans la variable 'species'
G = pkl.load(file1)

# Impression du contenu des données chargées (informations sur notre arbre)
print(G)

pip install asymmetree

files.upload()     # <================= Veuillez importer le fichier 'treebasednetworks.py'

from treebasednetworks import *

nbrCaractere=23

tree_builder = TreeBuilder()
# Affichage du graphe G avant l'elimination des transferts
tree_builder.drawGraph(G)

# Définition des attributs pour chaque nœud
labeler = LeafLabeler()
attributes = labeler.set_leaf_attributes(G, nbrCaractere)
print(attributes)

# Appel de la fonction eliminate_transfer_edges
transfer_manager = TransferManager()
G, attributes = transfer_manager.eliminate_transfer_edges(G, attributes, nbrCaractere)

# Affichage du graphe après l'élimination des arêtes "transfer"
print("Graphe après élimination des arêtes 'transfer':")
print(G.edges())

"""**Méthode2: Heuristique avec 10 itérations de transferts aléatoires.**"""

import pickle as pkl

# Ouverture du fichier pickle 'test1_species_tree.pkl' en mode lecture binaire
file1 = open('/content/output_algo2.pkl', 'rb')

# Chargement des données du fichier pickle dans la variable 'species'
G = pkl.load(file1)

# Impression du contenu des données chargées (informations sur notre arbre)
print(G)

from treebasednetworks import *

nbrCaractere=23
# Définition des attributs pour chaque nœud
labeler = LeafLabeler()
attributes = labeler.set_leaf_attributes(G, nbrCaractere)

# Initialisation des variables pour stocker la meilleure configuration
best_eliminated_edges_count = 0
best_G = None
best_attributes = None
G_copy1 = G.copy()
attributes_copy1 = attributes
# Répéter la méthode eliminate_transfer_edges 10 fois
for i in range(10):
    print("--------------- Itération ",i,"-------------------------")
    # Effectuer une copie du graphe et des attributs pour chaque itération
    G_copy = G_copy1.copy()
    attributes_copy = attributes_copy1

    # Appeler la fonction eliminate_transfer_edges pour cette itération
    transfer_manager = TransferManager()
    G_copy, attributes_copy, eliminated_edges_count = transfer_manager.eliminate_transfer_edges_random(G_copy, attributes_copy, nbrCaractere)



    # Vérifier si le nombre d'arêtes éliminées dans cette itération est le meilleur jusqu'à présent
    if eliminated_edges_count > best_eliminated_edges_count:
        best_eliminated_edges_count = eliminated_edges_count
        best_G = G_copy.copy()
        best_attributes = attributes_copy

# Afficher les résultats de la meilleure configuration
print("Meilleur nombre d'arêtes éliminées :", best_eliminated_edges_count)
print("Graphe correspondant à la meilleure configuration :", best_G)
print("attributes: ", attributes_copy)
if best_eliminated_edges_count >0:
   tree_builder = TreeBuilder()
   tree_builder.drawGraph(best_G)
else:
  print("il n'y a aucun TR à eliminer")