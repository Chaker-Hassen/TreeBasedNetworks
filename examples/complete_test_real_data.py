# -*- coding: utf-8 -*-
"""Complete_Test_Real_Data.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1diqDQnFMXhIha37rlpIdUxxUxu-DDf3g
"""

from google.colab import files

files.upload()     # <================= Veuillez importer le fichier 'treebasednetworks.py'

pip install asymmetree

files.upload() # <================= Veuillez importer le fichier 'inter_species_tree.pkl'

"""On a la variable 'species' qui est censée représenter notre arbre phylogénétique avec 70 noeuds (dont 25 noeuds internes et le reste sont des feuilles) et 69 branches."""

import pickle as pkl

# Ouverture du fichier pickle 'test1_species_tree.pkl' en mode lecture binaire
file1 = open('/content/inter_species_tree.pkl', 'rb')

# Chargement des données du fichier pickle dans la variable 'species'
species = pkl.load(file1)

# Impression du contenu des données chargées (informations sur notre arbre)
print(species)

files.upload() # <================= Veuillez importer le fichier 'interphylum_matrix.pkl'

"""Ce dictionnaire contient nos 45 espèces choisies au hasard de la base de données d'Orthologie KEGG (Encyclopédie Kyoto des Gènes et des Génomes).

Nous avons choisi 23 KOs en nous basant sur des caractéristiques qui ont amélioré les performances du modèle GCN.
"""

# Ouverture du fichier pickle 'test1_small_matrix.pkl' en mode lecture binaire
file2 = open('/content/interphylum_matrix.pkl', 'rb')

# Chargement des données du fichier pickle dans la variable 'dic' (qui représente un dictionnaire)
dic = pkl.load(file2)

# Impression du contenu du dictionnaire chargé
print(dic)

# Calcul et impression du nombre d'éléments dans le dictionnaire ( en principe egale au nbr des feuilles de notre arbre species)
len(dic)

"""On se basant sur l'algorithme 2 "Gluton", on va ajouter des transferts aux nœuds de notre arbre en fonction des attributs des nœuds afin de construire un Tree-Based Network PTN.

La sortie de l'algorithme 2, "Tree-based Network species," est stockée dans un fichier pickle "output_algo2".

=> Ce réseau présente un total de 528 arêtes, parmi lesquelles 459 ont été identifiées comme des transferts.

"""

from treebasednetworks import *


# Définir le nombre de caractères
nbrCaractere= 23

# Initialisation du l'arbre species
tree_builder = TreeBuilder()
species=tree_builder.initialize_graph(species, nbrCaractere)

# Trouver le nœud racine (source) de l'arbre
root_id = [node for node in species.nodes() if species.in_degree(node) == 0]

# Ajouter des timestamps aux nœuds du species
timestamp_manager = TimestampManager()
species=timestamp_manager.add_timestamp(species,root_id[0])

# Affichage l'arbre species
tree_builder.drawGraph(species)

# Etiquettage des feuilles de l'arbre species depuis dic.pkl
labeler = LeafLabeler()
species= labeler.label_tree_leaves_species(species, nbrCaractere, dic)
labeler.display_leaf_labels(species)

#attributes = labeling_internal_nodes(species, attributes)

# Définition des attributs pour chaque nœud
attributes = labeler.set_leaf_attributes(species, nbrCaractere)

# ---------------------- Appeler la fonction TransferAdditionGreedy ----------------------
# Ajouter des transferts aux nœuds de l'arbre en fonction des attributs des nœuds afin de construire un Tree-Based Network PTN.
tree_networks = TreeBasedNetworks()
species, attributes = tree_networks.TransferAdditionGreedy(species, attributes)

# Affichage des attributs mis à jour après l'application des transferts
print(attributes)
# Affichage du notre TBN species avec les nouvelles arêtes
tree_builder.drawGraph(species)

print(species)

# Affichage des timestamps des tous les nœuds du graphe
timestamp_manager.display_timestamps(species)

# Sauvegarde du notre TBN species dans un fichier pickle
file2= open('output_algo2.pkl','wb')
pkl.dump(species,file2)

"""
**Validation de la résultat de l'algorithme 2 en utilisant l'algorithme 1.**"""

# Définition des attributs pour chaque nœud
attributes = labeler.set_leaf_attributes(species,nbrCaractere)

print("\n-------------------------------------")
print(attributes)
print("\n-------------------------------------")
# Liste des caractères à vérifier
C = [f'c{i+1}' for i in range(nbrCaractere)]

# Appel de la fonction findLabeling (Algo1)
tree_networks = TreeBasedNetworks()
l = tree_networks.findLabeling(species, attributes, C)

# Affichage le dictionnaire des attributs final
print("\n----------------- Attributs final --------------------")
print(attributes)
print("\n-------------------------------------")

# Affichage des timestamps des tous les nœuds du graphe
timestamp_manager.display_timestamps(species)

"""--------------------------------------------------------------------------------
# **inferred_HGT**

**- À partir du résultat de l'algorithme 2, Gluton "output_algo2," nous allons construire le graphe HGT inféré où chaque nœud représente une espèce et chaque arête représente un événement de transfert.**

=> Nous avons identifié la présence de 412 arêtes et 45 nœuds dans le graphe "inferred_HGT_algo2".
"""

transfer_manager = TransferManager()
G, Tr=transfer_manager.extract_reachable_leaves_graph(species)

tree_builder.drawGraph(Tr)
print(Tr)

file3= open('inferred_HGT_algo2.pkl','wb')
pkl.dump(Tr,file3)



# Afficher les attributs des nœuds de Tr
print("Attributs des nœuds de Tr:")
for node, attributes in Tr.nodes(data=True):
    print(f"Feuille {Tr.nodes[node]['number']} {node}: {attributes}")

# Afficher les attributs des arêtes de Tr
print("Attributs des arêtes de Tr:")
for u, v, attributes in Tr.edges(data=True):
    print(f"Arête ({Tr.nodes[u]['number']}, {Tr.nodes[v]['number']}) : {attributes}")